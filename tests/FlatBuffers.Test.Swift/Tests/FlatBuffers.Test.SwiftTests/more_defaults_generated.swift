// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public struct MoreDefaults: FlatBufferObject, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_1_12_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsMoreDefaults(bb: ByteBuffer) -> MoreDefaults { return MoreDefaults(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ints = 4
    case floats = 6
    case emptyString = 8
    case someString = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var intsCount: Int32 { let o = _accessor.offset(VTOFFSET.ints.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ints(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.ints.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var ints: [Int32] { return _accessor.getVector(at: VTOFFSET.ints.v) ?? [] }
  public var floatsCount: Int32 { let o = _accessor.offset(VTOFFSET.floats.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func floats(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.floats.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var floats: [Float32] { return _accessor.getVector(at: VTOFFSET.floats.v) ?? [] }
  public var emptyString: String? { let o = _accessor.offset(VTOFFSET.emptyString.v); return o == 0 ? "" : _accessor.string(at: o) }
  public var emptyStringSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.emptyString.v) }
  public var someString: String? { let o = _accessor.offset(VTOFFSET.someString.v); return o == 0 ? "some" : _accessor.string(at: o) }
  public var someStringSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.someString.v) }
  public static func startMoreDefaults(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func addVectorOf(ints: Offset<UOffset>, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ints, at: VTOFFSET.ints.p) }
  public static func addVectorOf(floats: Offset<UOffset>, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: floats, at: VTOFFSET.floats.p) }
  public static func add(emptyString: Offset<String>, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: emptyString, at: VTOFFSET.emptyString.p) }
  public static func add(someString: Offset<String>, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: someString, at: VTOFFSET.someString.p) }
  public static func endMoreDefaults(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
  public static func createMoreDefaults(
    _ fbb: inout FlatBufferBuilder,
    intsVectorOffset ints: Offset<UOffset> = Offset(),
    floatsVectorOffset floats: Offset<UOffset> = Offset(),
    emptyStringOffset emptyString: Offset<String> = Offset(),
    someStringOffset someString: Offset<String> = Offset()
  ) -> Offset<UOffset> {
    let __start = MoreDefaults.startMoreDefaults(&fbb)
    MoreDefaults.addVectorOf(ints: ints, &fbb)
    MoreDefaults.addVectorOf(floats: floats, &fbb)
    MoreDefaults.add(emptyString: emptyString, &fbb)
    MoreDefaults.add(someString: someString, &fbb)
    return MoreDefaults.endMoreDefaults(&fbb, start: __start)
  }
  

  public mutating func unpack() -> MoreDefaultsT {
    return MoreDefaultsT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MoreDefaultsT?) -> Offset<UOffset> {
    guard var obj = obj else { return Offset<UOffset>() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MoreDefaultsT) -> Offset<UOffset> {
    let __ints = builder.createVector(obj.ints)
    let __floats = builder.createVector(obj.floats)
    let __emptyString: Offset<String>
    if let s = obj.emptyString {
      __emptyString = builder.create(string: s)
    } else {
      __emptyString = Offset<String>()
    }

    let __someString: Offset<String>
    if let s = obj.someString {
      __someString = builder.create(string: s)
    } else {
      __someString = Offset<String>()
    }

    let __root = MoreDefaults.startMoreDefaults(&builder)
    MoreDefaults.addVectorOf(ints: __ints, &builder)
    MoreDefaults.addVectorOf(floats: __floats, &builder)
    MoreDefaults.add(emptyString: __emptyString, &builder)
    MoreDefaults.add(someString: __someString, &builder)
    return MoreDefaults.endMoreDefaults(&builder, start: __root)
  }
}

public class MoreDefaultsT: NativeObject {

  public var ints: [Int32]
  public var floats: [Float32]
  public var emptyString: String?
  public var someString: String?

  public init(_ _t: inout MoreDefaults) {
    ints = []
    for index in 0..<_t.intsCount {
        ints.append(_t.ints(at: index))
    }
    floats = []
    for index in 0..<_t.floatsCount {
        floats.append(_t.floats(at: index))
    }
    emptyString = _t.emptyString
    someString = _t.someString
  }

  public init() {
    ints = []
    floats = []
    emptyString = ""
    someString = "some"
  }

  public func serialize() -> ByteBuffer { return serialize(type: MoreDefaults.self) }

}
