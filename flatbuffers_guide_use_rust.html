<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>FlatBuffers: Use in Rust</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400italic,500,500italic,700,700italic|Roboto+Mono:400,700" rel="stylesheet">
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea" style="height: 110px;">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="commonprojectlogo">
    <img alt="Logo" src="fpl_logo_small.png"/>
  </td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">FlatBuffers
   </div>
   <div style="font-size:12px;">
    An open source project by <a href="https://developers.google.com/games/#Tools">FPL</a>.
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('flatbuffers_guide_use_rust.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Use in Rust </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Before you get started</h2>
<p>Before diving into the FlatBuffers usage in Rust, it should be noted that the <a class="el" href="flatbuffers_guide_tutorial.html">Tutorial</a> page has a complete guide to general FlatBuffers usage in all of the supported languages (including Rust). This page is designed to cover the nuances of FlatBuffers usage, specific to Rust.</p>
<h4>Prerequisites</h4>
<p>This page assumes you have written a FlatBuffers schema and compiled it with the Schema Compiler. If you have not, please see <a class="el" href="flatbuffers_guide_using_schema_compiler.html">Using the schema compiler</a> and <a class="el" href="flatbuffers_guide_writing_schema.html">Writing a schema</a>.</p>
<p>Assuming you wrote a schema, say <code>mygame.fbs</code> (though the extension doesn't matter), you've generated a Rust file called <code>mygame_generated.rs</code> using the compiler (e.g. <code>flatc --rust mygame.fbs</code>), you can now start using this in your program by including the file. As noted, this header relies on the crate <code>flatbuffers</code>, which should be in your include <code>Cargo.toml</code>.</p>
<h2>FlatBuffers Rust library code location</h2>
<p>The code for the FlatBuffers Rust library can be found at <code>flatbuffers/rust</code>. You can browse the library code on the <a href="https://github.com/google/flatbuffers/tree/master/rust">FlatBuffers GitHub page</a>.</p>
<h2>Testing the FlatBuffers Rust library</h2>
<p>The code to test the Rust library can be found at <code>flatbuffers/tests/rust_usage_test</code>. The test code itself is located in <a href="https://github.com/google/flatbuffers/blob/master/tests/rust_usage_test/tests/integration_test.rs">integration_test.rs</a></p>
<p>This test file requires <code>flatc</code> to be present. To review how to build the project, please read the <a class="el" href="flatbuffers_guide_building.html">Building</a> documenation.</p>
<p>To run the tests, execute <code>RustTest.sh</code> from the <code>flatbuffers/tests</code> directory. For example, on <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>, you would simply run: <code>cd tests &amp;&amp; ./RustTest.sh</code>.</p>
<p><em>Note: The shell script requires <a href="https://www.rust-lang.org">Rust</a> to be installed.</em></p>
<h2>Using the FlatBuffers Rust library</h2>
<p><em>Note: See <a class="el" href="flatbuffers_guide_tutorial.html">Tutorial</a> for a more in-depth example of how to use FlatBuffers in Rust.</em></p>
<p>FlatBuffers supports both reading and writing FlatBuffers in Rust.</p>
<p>To use FlatBuffers in your code, first generate the Rust modules from your schema with the <code>--rust</code> option to <code>flatc</code>. Then you can import both FlatBuffers and the generated code to read or write FlatBuffers.</p>
<p>For example, here is how you would read a FlatBuffer binary file in Rust: First, include the library and generated code. Then read the file into a <code>u8</code> vector, which you pass, as a byte slice, to <code>get_root_as_monster()</code>.</p>
<p>This full example program is available in the Rust test suite: <a href="https://github.com/google/flatbuffers/blob/master/tests/rust_usage_test/bin/monster_example.rs">monster_example.rs</a></p>
<p>It can be run by <code>cd</code>ing to the <code>rust_usage_test</code> directory and executing: <code>cargo run monster_example</code>.</p>
<div class="fragment"><div class="line">extern crate flatbuffers;</div><div class="line"></div><div class="line">#[path = &quot;../../monster_test_generated.rs&quot;]</div><div class="line">mod monster_test_generated;</div><div class="line">pub use monster_test_generated::my_game;</div><div class="line"></div><div class="line">use std::io::Read;</div><div class="line"></div><div class="line">fn main() {</div><div class="line">    let mut f = std::fs::File::open(&quot;../monsterdata_test.mon&quot;).unwrap();</div><div class="line">    let mut buf = Vec::new();</div><div class="line">    f.read_to_end(&amp;mut buf).expect(&quot;file reading failed&quot;);</div><div class="line"></div><div class="line">    let monster = my_game::example::get_root_as_monster(&amp;buf[..]);</div></div><!-- fragment --><p><code>monster</code> is of type <code>Monster</code>, and points to somewhere <em>inside</em> your buffer (root object pointers are not the same as <code>buffer_pointer</code> !). If you look in your generated header, you'll see it has convenient accessors for all fields, e.g. <code>hp()</code>, <code>mana()</code>, etc:</p>
<div class="fragment"><div class="line">    println!(&quot;{}&quot;, monster.hp());     // `80`</div><div class="line">    println!(&quot;{}&quot;, monster.mana());   // default value of `150`</div><div class="line">    println!(&quot;{:?}&quot;, monster.name()); // Some(&quot;MyMonster&quot;)</div><div class="line">}</div></div><!-- fragment --><p><em>Note: That we never stored a <code>mana</code> value, so it will return the default.</em></p>
<h2>Direct memory access</h2>
<p>As you can see from the above examples, all elements in a buffer are accessed through generated accessors. This is because everything is stored in little endian format on all platforms (the accessor performs a swap operation on big endian machines), and also because the layout of things is generally not known to the user.</p>
<p>For structs, layout is deterministic and guaranteed to be the same across platforms (scalars are aligned to their own size, and structs themselves to their largest member), and you are allowed to access this memory directly by using <code>safe_slice</code> and on the reference to a struct, or even an array of structs.</p>
<p>To compute offsets to sub-elements of a struct, make sure they are structs themselves, as then you can use the pointers to figure out the offset without having to hardcode it. This is handy for use of arrays of structs with calls like <code>glVertexAttribPointer</code> in OpenGL or similar APIs.</p>
<p>It is important to note is that structs are still little endian on all machines, so only use tricks like this if you can guarantee you're not shipping on a big endian machine (using an <code>#[cfg(target_endian = "little")]</code> attribute would be wise).</p>
<p>The special function <code>safe_slice</code> is implemented on Vector objects that are represented in memory the same way as they are represented on the wire. This function is always available on vectors of struct, bool, u8, and i8. It is conditionally-compiled on little-endian systems for all the remaining scalar types.</p>
<p>The FlatBufferBuilder function <code>create_vector_direct</code> is implemented for all types that are endian-safe to write with a <code>memcpy</code>. It is the write-equivalent of <code>safe_slice</code>.</p>
<h2>Access of untrusted buffers</h2>
<p>The generated accessor functions access fields over offsets, which is very quick. These offsets are used to index into Rust slices, so they are bounds-checked by the Rust runtime. However, our Rust implementation may change: we may convert access functions to use direct pointer dereferencing, to improve lookup speed. As a result, users should not rely on the aforementioned bounds-checking behavior.</p>
<p>When you're processing large amounts of data from a source you know (e.g. your own generated data on disk), this is acceptable, but when reading data from the network that can potentially have been modified by an attacker, this is undesirable.</p>
<p>The C++ port provides a buffer verifier. At this time, Rust does not. Rust may provide a verifier in a future version. In the meantime, Rust users can access the buffer verifier generated by the C++ port through a foreign function interface (FFI).</p>
<h2>Threading</h2>
<p>Reading a FlatBuffer does not touch any memory outside the original buffer, and is entirely read-only (all immutable), so is safe to access from multiple threads even without synchronisation primitives.</p>
<p>Creating a FlatBuffer is not thread safe. All state related to building a FlatBuffer is contained in a FlatBufferBuilder instance, and no memory outside of it is touched. To make this thread safe, either do not share instances of FlatBufferBuilder between threads (recommended), or manually wrap it in synchronisation primitives. There's no automatic way to accomplish this, by design, as we feel multithreaded construction of a single buffer will be rare, and synchronisation overhead would be costly.</p>
<p><br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-49880327-7', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
